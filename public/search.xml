<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux下安装pcre</title>
    <url>/2021/02/23/Linux%E4%B8%8B%E5%AE%89%E8%A3%85pcre/</url>
    <content><![CDATA[<p>PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。</p>
<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><h5 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h5><h6 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;ftp.pcre.org&#x2F;pub&#x2F;pcre&#x2F;pcre-8.44.tar.gz </span><br></pre></td></tr></table></figure>
<h6 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxf pcre-8.10.tar.gz</span><br></pre></td></tr></table></figure>
<h6 id="进入解压好的目录"><a href="#进入解压好的目录" class="headerlink" title="进入解压好的目录"></a>进入解压好的目录</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd pcre-8.10.tar.gz</span><br></pre></td></tr></table></figure>
<h6 id="执行配置"><a href="#执行配置" class="headerlink" title="执行配置"></a>执行配置</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>
<h6 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Linux下安装和配置nginx</title>
    <url>/2021/02/23/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEnginx/</url>
    <content><![CDATA[<h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><h4 id="Nginx是什么？"><a href="#Nginx是什么？" class="headerlink" title="Nginx是什么？"></a>Nginx是什么？</h4><p>Nginx是一款轻量级Web服务器，也是一款反向代理服务器</p>
<blockquote>
<p>官网：<a href="http://nginx.org/">http://nginx.org/</a><br>中文文档: <a href="http://www.nginx.cn/doc/">http://www.nginx.cn/doc/</a></p>
</blockquote>
<h4 id="Nginx能干什么"><a href="#Nginx能干什么" class="headerlink" title="Nginx能干什么?"></a>Nginx能干什么?</h4><p>Nginx能干的事情很多,这里简要罗列一-些：</p>
<p>可直接支持Rails和PHP的程序<br>可作为HTTP反向代理服务器<br>作为负载均衡服务器<br>作为邮件代理服务器<br>帮助实现前端动静分离</p>
<h4 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h4><h5 id="Nginx下载"><a href="#Nginx下载" class="headerlink" title="Nginx下载"></a>Nginx下载</h5><blockquote>
<p>官网下载：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p>
</blockquote>
<h5 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h5><h6 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>
<h6 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>
<h6 id="进入解压好的目录"><a href="#进入解压好的目录" class="headerlink" title="进入解压好的目录"></a>进入解压好的目录</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nginx-1.12.2&#x2F;</span><br></pre></td></tr></table></figure>
<h6 id="执行配置"><a href="#执行配置" class="headerlink" title="执行配置"></a>执行配置</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>
<h6 id="编译安装-默认安装在-usr-local-nginx"><a href="#编译安装-默认安装在-usr-local-nginx" class="headerlink" title="编译安装(默认安装在/usr/local/nginx)"></a>编译安装(默认安装在/usr/local/nginx)</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2021/02/22/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>在当前目录新建一个Git代码库</p>
<pre><code>git init [project-name]
</code></pre>
<p>新建一个目录，将其初始化为Git代码库</p>
<pre><code>git clone [url]
</code></pre>
<p>下载一个项目和它的整个代码历史</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<pre><code>git config --list
</code></pre>
<p>显示当前的Git配置</p>
<pre><code>git config -e [--global]
</code></pre>
<p>编辑Git配置文件</p>
<pre><code>git config [--global] user.name &quot;[name]&quot;
git config [--global] user.email &quot;[email address]&quot;
</code></pre>
<p>设置提交代码时的用户信息</p>
<h4 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h4><p>添加指定文件到暂存区</p>
<pre><code>git add [file1] [file2] ...
</code></pre>
<p>添加指定目录到暂存区，包括子目录</p>
<pre><code>git add [dir]
</code></pre>
<p>添加当前目录的所有文件到暂存区</p>
<pre><code>git add .
</code></pre>
<p>添加每个变化前，都会要求确认<br>对于同一个文件的多处变化，可以实现分次提交</p>
<pre><code>git add -p
</code></pre>
<p>删除工作区文件，并且将这次删除放入暂存区</p>
<pre><code>git rm [file1] [file2] ...
</code></pre>
<p>停止追踪指定文件，但该文件会保留在工作区</p>
<pre><code>git rm --cached [file]
</code></pre>
<p>改名文件，并且将这个改名放入暂存区</p>
<pre><code>git mv [file-original] [file-renamed]
</code></pre>
<h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><p>提交暂存区到仓库区</p>
<pre><code>git commit -m [message]
</code></pre>
<p>提交暂存区的指定文件到仓库区</p>
<pre><code>git commit [file1] [file2] ... -m [message]
</code></pre>
<p>提交工作区自上次commit之后的变化，直接到仓库区</p>
<pre><code>git commit -a
</code></pre>
<p>提交时显示所有diff信息</p>
<pre><code>git commit -v
</code></pre>
<p>使用一次新的commit，替代上一次提交<br>如果代码没有任何新变化，则用来改写上一次commit的提交信息</p>
<pre><code>git commit --amend -m [message]
</code></pre>
<p>重做上一次commit，并包括指定文件的新变化</p>
<pre><code>git commit --amend [file1] [file2] ...
</code></pre>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>列出所有本地分支</p>
<pre><code>git branch
</code></pre>
<p>列出所有远程分支</p>
<pre><code>git branch -r
</code></pre>
<p>列出所有本地分支和远程分支</p>
<pre><code>git branch -a
</code></pre>
<p>新建一个分支，但依然停留在当前分支</p>
<pre><code>git branch [branch-name]
</code></pre>
<p>新建一个分支，并切换到该分支</p>
<pre><code>git checkout -b [branch]
</code></pre>
<p>新建一个分支，指向指定commit</p>
<pre><code>git branch [branch] [commit]
</code></pre>
<p>新建一个分支，与指定的远程分支建立追踪关系</p>
<pre><code>git branch --track [branch] [remote-branch]
</code></pre>
<p>切换到指定分支，并更新工作区</p>
<pre><code>git checkout [branch-name]
</code></pre>
<p>切换到上一个分支</p>
<pre><code>git checkout -
</code></pre>
<p>建立追踪关系，在现有分支与指定的远程分支之间</p>
<pre><code>git branch --set-upstream [branch] [remote-branch]
</code></pre>
<p>合并指定分支到当前分支</p>
<pre><code>git merge [branch]
</code></pre>
<p>选择一个commit，合并进当前分支</p>
<pre><code>git cherry-pick [commit]
</code></pre>
<p>删除分支</p>
<pre><code>git branch -d [branch-name]
</code></pre>
<p>删除远程分支</p>
<pre><code>git push origin --delete [branch-name]

git branch -dr [remote/branch]
</code></pre>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>列出所有tag</p>
<pre><code>git tag
</code></pre>
<p>新建一个tag在当前commit</p>
<pre><code>git tag [tag]
</code></pre>
<p>新建一个tag在指定commit</p>
<pre><code>git tag [tag] [commit]
</code></pre>
<p>删除本地tag</p>
<pre><code>git tag -d [tag]
</code></pre>
<p>删除远程tag</p>
<pre><code>git push origin :refs/tags/[tagName]
</code></pre>
<p>查看tag信息</p>
<pre><code>git show [tag]
</code></pre>
<p>提交指定tag</p>
<pre><code>git push [remote] [tag]
</code></pre>
<p>提交所有tag</p>
<pre><code>git push [remote] --tags
</code></pre>
<p>新建一个分支，指向某个tag</p>
<pre><code>git checkout -b [branch] [tag]
</code></pre>
<h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><p>显示有变更的文件</p>
<pre><code>git status
</code></pre>
<p>显示当前分支的版本历史</p>
<pre><code>git log
</code></pre>
<p>显示commit历史，以及每次commit发生变更的文件</p>
<pre><code>git log --stat
</code></pre>
<p>搜索提交历史，根据关键词</p>
<pre><code>git log -S [keyword]
</code></pre>
<p>显示某个commit之后的所有变动，每个commit占据一行</p>
<pre><code>git log [tag] HEAD --pretty=format:%s
</code></pre>
<p>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p>
<pre><code>git log [tag] HEAD --grep feature
</code></pre>
<p>显示某个文件的版本历史，包括文件改名</p>
<pre><code>git log --follow [file]

git whatchanged [file]
</code></pre>
<p>显示指定文件相关的每一次diff</p>
<pre><code>git log -p [file]
</code></pre>
<p>显示过去5次提交</p>
<pre><code>git log -5 --pretty --oneline
</code></pre>
<p>显示所有提交过的用户，按提交次数排序</p>
<pre><code>git shortlog -sn
</code></pre>
<p>显示指定文件是什么人在什么时间修改过</p>
<pre><code>git blame [file]
</code></pre>
<p>显示暂存区和工作区的差异</p>
<pre><code>git diff
</code></pre>
<p>显示暂存区和上一个commit的差异</p>
<pre><code>git diff --cached [file]
</code></pre>
<p>显示工作区与当前分支最新commit之间的差异</p>
<pre><code>git diff HEAD
</code></pre>
<p>显示两次提交之间的差异</p>
<pre><code>git diff [first-branch]...[second-branch]
</code></pre>
<p>显示今天你写了多少行代码</p>
<pre><code>git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;
</code></pre>
<p>显示某次提交的元数据和内容变化</p>
<pre><code>git show [commit]
</code></pre>
<p>显示某次提交发生变化的文件</p>
<pre><code>git show --name-only [commit]
</code></pre>
<p>显示某次提交时，某个文件的内容</p>
<pre><code>git show [commit]:[filename]
</code></pre>
<p>显示当前分支的最近几次提交</p>
<pre><code>git reflog
</code></pre>
<h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><p>下载远程仓库的所有变动</p>
<pre><code>git fetch [remote]
</code></pre>
<p>显示所有远程仓库</p>
<pre><code>git remote -v
</code></pre>
<p>显示某个远程仓库的信息</p>
<pre><code>git remote show [remote]
</code></pre>
<p>增加一个新的远程仓库，并命名</p>
<pre><code>git remote add [shortname] [url]
</code></pre>
<p>取回远程仓库的变化，并与本地分支合并</p>
<pre><code>git pull [remote] [branch]
</code></pre>
<p>上传本地指定分支到远程仓库</p>
<pre><code>git push [remote] [branch]
</code></pre>
<p>强行推送当前分支到远程仓库，即使有冲突</p>
<pre><code>git push [remote] --force
</code></pre>
<p>推送所有分支到远程仓库</p>
<pre><code>git push [remote] --all
</code></pre>
<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p>恢复暂存区的指定文件到工作区</p>
<pre><code>git checkout [file]
</code></pre>
<p>恢复某个commit的指定文件到暂存区和工作区</p>
<pre><code>git checkout [commit] [file]
</code></pre>
<p>恢复暂存区的所有文件到工作区</p>
<pre><code>git checkout .
</code></pre>
<p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>
<pre><code>git reset [file]
</code></pre>
<p>重置暂存区与工作区，与上一次commit保持一致</p>
<pre><code>git reset --hard
</code></pre>
<p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>
<pre><code>git reset [commit]
</code></pre>
<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>
<pre><code>git reset --hard [commit]
</code></pre>
<p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>
<pre><code>git reset --keep [commit]
</code></pre>
<p>新建一个commit，用来撤销指定commit<br>后者的所有变化都将被前者抵消，并且应用到当前分支</p>
<pre><code>git revert [commit]
</code></pre>
<p>暂时将未提交的变化移除，稍后再移入</p>
<pre><code>git stash

git stash pop
</code></pre>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>前端页面一键部署到服务器</title>
    <url>/2021/02/24/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="通过ssh本地文件给上传到远程服务器"><a href="#通过ssh本地文件给上传到远程服务器" class="headerlink" title="通过ssh本地文件给上传到远程服务器"></a>通过ssh本地文件给上传到远程服务器</h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install ssh2-sftp-client -D</span><br></pre></td></tr></table></figure>
<h3 id="新建sftp-js文件"><a href="#新建sftp-js文件" class="headerlink" title="新建sftp.js文件"></a>新建sftp.js文件</h3><p>在文件夹根目录新建一个sftp.js文件</p>
<h3 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Client &#x3D; require(&quot;ssh2-sftp-client&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line">&#x2F;&#x2F; const path &#x3D; require(&#39;path&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 先配置一下,个人习惯</span><br><span class="line">const config &#x3D; &#123;</span><br><span class="line">  path: &#123;</span><br><span class="line">    &#x2F;&#x2F; 远程地址 从根目录开始的路径</span><br><span class="line">    romotePath: &quot;&#x2F;data1&#x2F;web&#x2F;blog&quot;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 本地地址 相对于当前文件夹所在的路径</span><br><span class="line">    localPath: path.join(__dirname, &quot;.&#x2F;public&quot;).replace(&#x2F;\\&#x2F;g, &quot;&#x2F;&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  romote: &#123;</span><br><span class="line">    &#x2F;&#x2F; 服务器 ip 地址</span><br><span class="line">    host: &quot;**************&quot;,</span><br><span class="line">    &#x2F;&#x2F; 端口号,默认是 22</span><br><span class="line">    port: &quot;22&quot;,</span><br><span class="line">    &#x2F;&#x2F; 登录的用户名</span><br><span class="line">    username: &quot;root&quot;,</span><br><span class="line">    &#x2F;&#x2F; 登录密码</span><br><span class="line">    password: &quot;***************&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 主方法</span><br><span class="line">* @method main</span><br><span class="line">* @param&#123;String&#125; localPath 本地路径,不用 path 模块,直接字符串就好了,这个包自己有格式化的</span><br><span class="line">* @param&#123;String&#125; romotePath 远程路径</span><br><span class="line">* @return&#123;undefined&#125; 返回个*</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">function main(localPath, romotePath) &#123;</span><br><span class="line">  &#x2F;&#x2F; 实例化</span><br><span class="line">  const sftp &#x3D; new Client();</span><br><span class="line">  sftp</span><br><span class="line">    .connect(config.romote)</span><br><span class="line">    &#x2F;&#x2F;  先递归删除服务器上的文件夹</span><br><span class="line">    .then(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(</span><br><span class="line">        &quot;----------------------------- 删除服务器缓存中... -----------------------------&quot;</span><br><span class="line">      );</span><br><span class="line">      return sftp.rmdir(romotePath, true);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then((data) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(</span><br><span class="line">        &quot;----------------------------- 删除完成 ----------------------------&quot;</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(</span><br><span class="line">        &quot;----------------------------- 连接成功,上传中... -----------------------------&quot;</span><br><span class="line">      );</span><br><span class="line">      return sftp.uploadDir(localPath, romotePath);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then((data) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(</span><br><span class="line">        &quot;----------------------------- 上传完成,及时清除缓存 ----------------------------&quot;</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((err) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(</span><br><span class="line">        &quot;----------------------------- 失败了!出事了!快看看怎么回事! -----------------------------&quot;</span><br><span class="line">      );</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">    .finally(() &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 断开连接</span><br><span class="line">      sftp.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">main(config.path.localPath, config.path.romotePath);</span><br></pre></td></tr></table></figure>
<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>在当前文件夹中打开终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node .&#x2F;sftp.js</span><br></pre></td></tr></table></figure>
<h4 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h4><p>在package.json 新增一个scripts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;generate&quot;:&quot;hexo generate &amp;&amp; node .&#x2F;sftp.js&quot;</span><br></pre></td></tr></table></figure>
<p>这样就可以在生成完静态文件之后直接上传到服务器了</p>
]]></content>
  </entry>
  <entry>
    <title>get和post的区别</title>
    <url>/2021/02/26/Get%E5%92%8CPost%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h1><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p><strong>说GET和POST之前就先来看一下什么是HTTP吧。</strong></p>
<p>超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。<br>HTTP 的工作方式是客户机与服务器之间的请求-应答协议。<br>web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。<br>举例：客户端（浏览器）向服务器提交HTTP请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。</p>
<p>HTTP的请求方法有以下的八种：</p>
<pre><code>1. GET 向服务器获取指定资源
2. HEAD 与GET一致，只不过响应体不返回，只返回响应头
3. POST 向服务器提交数据，数据放在请求体里
4. PUT 与POST相似，只是具有幂等（注1）特性，一般用于更新
5. DELETE 删除服务器指定资源
6. TRACE 回显服务器端收到的请求，测试的时候会用到这个
7. CONNECT 预留，暂无使用
8. OPTIONS 返回服务器所支持的请求方法
</code></pre>
<h5 id="随便一个计算机从业人员都可以说出一些他们的区别，例如："><a href="#随便一个计算机从业人员都可以说出一些他们的区别，例如：" class="headerlink" title="随便一个计算机从业人员都可以说出一些他们的区别，例如："></a>随便一个计算机从业人员都可以说出一些他们的区别，例如：</h5><pre><code>1. GET方法用于信息获取，它是安全的（安全：指非修改信息，如数据库方面的信息），而POST方法是用于修改服务器上资源的请求；

2. GET请求的数据会附在URL之后，而POST方法提交的数据则放置在HTTP报文实体的主体里，所以POST方法的安全性比GET方法要高；

3. GET方法传输的数据量一般限制在2KB，其原因在于：GET是通过URL提交数据，而URL本身对于数据没有限制，但是不同的浏览器对于URL是有限制的，比如IE浏览器对于URL的限制为2KB，而Chrome，FireFox浏览器理论上对于URL是没有限制的，它真正的限制取决于操作系统本身；POST方法对于数据大小是无限制的，真正影响到数据大小的是服务器处理程序的能力。
</code></pre>
<blockquote>
<p>本质上，GET和POST是没有区别的，他们都是http协议中的两种发送请求的方法，而http是基于TCP/IP的关于数据如何在万维网中通信的协议<br>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p>
</blockquote>
<h5 id="再来看看HTTP报文"><a href="#再来看看HTTP报文" class="headerlink" title="再来看看HTTP报文"></a>再来看看HTTP报文</h5><p>报文格式上，不带参数时，最大区别就是第一行方法名不同POST方法请求报文第一行是这样的 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">POST /uri HTTP/<span class="number">1.1</span> \r\n</span><br></pre></td></tr></table></figure>
<p>GET方法请求报文第一行是这样的 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /uri HTTP/<span class="number">1.1</span> \r\n</span><br></pre></td></tr></table></figure>
<p>是的，不带参数时他们的区别就仅仅是报文的前几个字符不同而已带参数时报文的区别呢？ 在约定中，GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中举个例子，如果参数是 name=qiming.c, age=22。GET 方法简约版报文是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /index.php?name=qiming.c&amp;age=<span class="number">22</span> HTTP/<span class="number">1.1</span></span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure>
<p>POST 方法简约版报文是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">POST /index.php HTTP/<span class="number">1.1</span></span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">name=qiming.c&amp;age=<span class="number">22</span></span><br></pre></td></tr></table></figure>
<h5 id="POST-方法会产生两个TCP数据包？"><a href="#POST-方法会产生两个TCP数据包？" class="headerlink" title="POST 方法会产生两个TCP数据包？"></a>POST 方法会产生两个TCP数据包？</h5><p>有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。</p>
<p>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。</p>
<p>所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><pre><code>1. 幂等 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.
</code></pre>
]]></content>
      <categories>
        <category>面试必看</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>爱生气的书店老板</title>
    <url>/2021/02/23/leetCode/%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="爱生气的书店老板"><a href="#爱生气的书店老板" class="headerlink" title="爱生气的书店老板"></a>爱生气的书店老板</h3><p>今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p>
<p>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p>
<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p>
<p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p>
<h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><pre><code>输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
输出：16
解释：
书店老板在最后 3 分钟保持冷静。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
</code></pre>
<p> </p>
<h6 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h6><pre><code>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000
0 &lt;= customers[i] &lt;= 1000
0 &lt;= grumpy[i] &lt;= 1
</code></pre>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol>
<li>既然要算出最多有多少客户能感到满意的数量，那么可以先把必定满意也就是grumpy[i]的值为0的客户数量加起来，然后把customers[i]置为0</li>
<li>利用窗口算法，找到在customers中X个值之和最大的值</li>
</ol>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;number[]&#125; customers</span><br><span class="line">* @param &#123;number[]&#125; grumpy</span><br><span class="line">* @param &#123;number&#125; X</span><br><span class="line">* @return &#123;number&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">var maxSatisfied &#x3D; function(customers, grumpy, X) &#123;</span><br><span class="line">  let len &#x3D; customers.length;</span><br><span class="line">  let cur &#x3D; 0;</span><br><span class="line">  for(let i &#x3D; 0;i &lt; len;i++)&#123;</span><br><span class="line">    if(grumpy[i] &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      cur +&#x3D; customers[i];</span><br><span class="line">      customers[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let max &#x3D; 0,sum &#x3D; 0;</span><br><span class="line">  for(let right &#x3D; 0,left &#x3D; 0;right &lt; len;right++)&#123;</span><br><span class="line">    sum +&#x3D; customers[right];</span><br><span class="line">    &#x2F;&#x2F;  如果right - left的值大于X - 1 说明此时sum的值为X个值的和 那么就将当前窗口向右移动一个位置 也就是减去左边第一个值并将left + 1</span><br><span class="line">    if(right - left + 1 &gt; X) sum -&#x3D; customers[left++];</span><br><span class="line">    max &#x3D; Math.max(max, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  return cur + max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="来源：力扣（LeetCode）"><a href="#来源：力扣（LeetCode）" class="headerlink" title="来源：力扣（LeetCode）"></a>来源：力扣（LeetCode）</h5><blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner">https://leetcode-cn.com/problems/grumpy-bookstore-owner</a></p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>leetcode</tag>
        <tag>每日打卡</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>至少有 K 个重复字符的最长子串</title>
    <url>/2021/02/27/leetCode/%E8%87%B3%E5%B0%91%E6%9C%89%20K%20%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="至少有-K-个重复字符的最长子串"><a href="#至少有-K-个重复字符的最长子串" class="headerlink" title="至少有 K 个重复字符的最长子串"></a>至少有 K 个重复字符的最长子串</h3><p>给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。</p>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><pre><code>输入：s = &quot;aaabb&quot;, k = 3
输出：3
解释：最长子串为 &quot;aaa&quot; ，其中 &#39;a&#39; 重复了 3 次。
</code></pre>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><pre><code>输入：s = &quot;ababbc&quot;, k = 2
输出：5
解释：最长子串为 &quot;ababb&quot; ，其中 &#39;a&#39; 重复了 2 次， &#39;b&#39; 重复了 3 次。
</code></pre>
<p> </p>
<h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><ol>
<li>1 &lt;= s.length &lt;= 104</li>
<li>s 仅由小写英文字母组成</li>
<li>1 &lt;= k &lt;= 105</li>
</ol>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>/**
  * @param &#123;string&#125; s
  * @param &#123;number&#125; k
  * @return &#123;number&#125;
*/
var longestSubstring = function(s, k) &#123;

&#125;;
</code></pre>
<h6 id="来源：力扣（LeetCode）"><a href="#来源：力扣（LeetCode）" class="headerlink" title="来源：力扣（LeetCode）"></a>来源：力扣（LeetCode）</h6><blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters</a></p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>leetcode</tag>
        <tag>每日打卡</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的兼容性</title>
    <url>/2021/02/26/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="什么是浏览器的兼容性"><a href="#什么是浏览器的兼容性" class="headerlink" title="什么是浏览器的兼容性"></a>什么是浏览器的兼容性</h1><p>浏览器兼容性问题又被称为网页兼容性或网站兼容性问题，指网页在各种浏览器上的显示效果可能不一致而产生浏览器和网页间的兼容问题。所以在网站的设计和制作中，做好浏览器兼容，才能够让网站在不同的浏览器下都正常显示。</p>
<blockquote>
<p>浏览器的兼容性无非还是样式兼容性（css），交互兼容性（javascript），浏览器 hack 三个方面</p>
</blockquote>
<h2 id="样式兼容性-css"><a href="#样式兼容性-css" class="headerlink" title="样式兼容性(css)"></a>样式兼容性(css)</h2><p><img src="https://user-gold-cdn.xitu.io/2018/7/5/16468bfe8343415c?imageslim" alt="image"></p>
<p><a href="https://github.com/necolas/normalize.css">normalize.css</a></p>
<p>1.图片间隙</p>
<pre><code>div中的图片间隙
bug：在块元素中插入图片时，有时图片会将块元素下方撑大三像素。
Hack：给&lt;img&gt;添加声明：display:block
</code></pre>
<p>2.表单元素行高不一致(IE,MOZ,C,O,S)</p>
<pre><code>bug：表单元素行高对齐方式不一致
hack：给表单元素添加声明：float:left;
</code></pre>
<p>3.按钮元素默认大小及样式不一致</p>
<pre><code>hack1： 统一大小及样式（用a标记模拟）
hack2：如果这个按钮是一个图片，直接把图片作为按钮的背景图即可。
</code></pre>
<p>4.鼠标指针bug</p>
<pre><code>描述：cursor属性的hand属性值只有IE8浏览器识别;
hack：如统一某元素鼠标指针形状为手型，应添加声明：cursor:pointer;
</code></pre>
<p>5.透明属性</p>
<pre><code>IE浏览器写法：filter:alpha(opacity=数值);取值范围 1-100(IE8以下)
兼容其他浏览器写法：opacity:数值;(数值的取值范围0-1,0.1,0.2,0.3-----0.9)
</code></pre>
<p>6.父元素里有块元素，如果给子元素添加添加margin-top,父元素会“掉”下来（高度塌陷）</p>
<pre><code>hack1：给父元素添加overflow：hidden；
hack2：给子元素添加float；
hack3：给父元素加边框；
或者用其他的方法达到我们想要的效果：如给父元素加padding-top
</code></pre>
<p>7.双倍浮向（双倍边距）</p>
<pre><code>描述：当Ie6及更低版本浏览器在解析浮动元素时，会错误地把浮向边的边界加倍显示。
hack:给浮动元素添加声明：display:inline;
</code></pre>
<p>8.当li里的A加display:block或float:left时，出现行高不一致，有的会多出3像素</p>
<pre><code>hack1：给a加display：inline-block;
hack2：给a加display：inline;
hack3：给li加float，再加宽度
</code></pre>
<p>9.万能清除浮动法</p>
<pre><code>父元素选择符:after&#123;content:&quot;.&quot;; clear:both; display:block; height:0; overflow:hidden; visibility:hidden;&#125;
</code></pre>
<p>10.行内块元素之间空白缝隙的问题</p>
<pre><code>hack1：利用margin 负值，例如Margin-left:-8px;
hack2：把行内块写到一行上去
hack3：给父盒子加:font-size:0;
</code></pre>
<h2 id="交互兼容性"><a href="#交互兼容性" class="headerlink" title="交互兼容性"></a>交互兼容性</h2><p><img src="https://pic2.zhimg.com/v2-dc2e8fa38c0096dac0aeec90b600ac81_b.jpg" alt="image"></p>
<p>1、event事件</p>
<pre><code>通用方式
document.onclick=function(e)&#123;
    var e = e || window.event;   //兼容写法
&#125;
</code></pre>
<p>2、一些“方法”的兼容性写法</p>
<pre><code>停止事件传播
if(evt.stopPropagation)&#123;
    return evt.stopPropagation();    //一定不能漏下evt  方法前一定要写明对象
&#125;else&#123;
    return evt.cancelbuble();
&#125;

阻止默认事件
if (e.preventDefault) &#123;
     e.preventDefault();   //W3C标准
&#125;else&#123;
     e.returnValue = &#39;false&#39;;    //IE
&#125;

获取第一个子节点（next，last都类似）
if (obj.lastElementChild) &#123;
     return obj.firstElementChild;   //非IE6/7/8支持
&#125; else&#123;
     return obj.firstChild;   //IE6/7/8支持
&#125;;

设置监听事件
//参数一：对象
//参数二：事件类型
//参数三：事件处理函数
function addEvent(obj, type, fn)&#123;
     if (obj.addEventListener) &#123;
          obj.addEventListener(type, fn, false);  //非IE
     &#125; else&#123;
          obj.attachEvent(&#39;on&#39; + type, fn);  //IE
     &#125;
&#125;
</code></pre>
<p>3、通过className获取DOM节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClassName</span>(<span class="params">xxx</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> atag = <span class="built_in">document</span>.all ? <span class="built_in">document</span>.all : <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">     <span class="keyword">var</span> arr = [];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; atag.length; i++) &#123;</span><br><span class="line">         <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\\b&#x27;</span> + xxx + <span class="string">&#x27;\\b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">         <span class="keyword">if</span> (reg.test(atag[i].className)) &#123;</span><br><span class="line">             arr.push(atag[i]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> arr;  <span class="comment">//返回的也是数组，包含传入的class所有元素；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、event.srcElement问题</p>
<pre><code>IE：event对象有srcElement属性，没有target属性；
Firefox:even对象有target属性，没有srcElement属性。
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">srcObj = event.srcElement ? event.srcElement : event.target;</span><br></pre></td></tr></table></figure>
<p>5、firefox与IE的父元素(parentElement)的区别</p>
<pre><code>IE：obj.parentElement
firefox：obj.parentNode
hack：都使用obj.parentNode
</code></pre>
<h2 id="移动端常见案例"><a href="#移动端常见案例" class="headerlink" title="移动端常见案例"></a>移动端常见案例</h2><p>1、部分情况下对非可点击元素如(label,span)监听click事件时，ios下不会触发</p>
<pre><code>hack：css中增加cursor:pointer
</code></pre>
<p>2、底部输入框被键盘遮挡问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oheight = $(<span class="built_in">document</span>).height(); <span class="comment">//浏览器当前的高度</span></span><br><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>($(<span class="built_in">document</span>).height() &lt; oheight)&#123;</span><br><span class="line">          $(<span class="string">&quot;#footer&quot;</span>).css(<span class="string">&quot;position&quot;</span>, <span class="string">&quot;static&quot;</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          $(<span class="string">&quot;#footer&quot;</span>).css(<span class="string">&quot;position&quot;</span>, <span class="string">&quot;absolute&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3、CSS动画页面闪白,动画卡顿</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用综合属性</span></span><br><span class="line">-webkit-transform: translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">-moz-transform: translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">-ms-transform: translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">transform: translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>4、阻止旋转屏幕时自动调整字体大小</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123;-webkit-text-size-adjust:none;&#125;</span><br></pre></td></tr></table></figure>
<p>5、预加载、自动播放无效</p>
<p>自动播放的有效性受操作系统、浏览器（webview）、版本等的影响，苹果官方规定必须由用户手动触发才会载入音频，所以可以在用户依次输入后，让音频实现预加载:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;audio&#x27;</span>)[<span class="number">0</span>].play();</span><br><span class="line">     <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;audio&#x27;</span>)[<span class="number">0</span>].pause();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>6、ios safari时间显示问题</p>
<pre><code>设置new Date日期格式的时候，在ios中的safari中发现显示效果与其他浏览器不一致。
只识别：new Date(&quot;year/month/day&quot;);
</code></pre>
<p>7、移动端300ms延迟。</p>
<pre><code>hack1：一般在移动端用tap事件来取代click事件
hack2：fastclick可以解决在手机上点击事件的300ms延迟
</code></pre>
<p>8、手机上的flex布局时会有兼容性问题</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;  //老版本语法: Safari, iOS, Android browser, older WebKit browsers. </span><br><span class="line">    display: -moz-box;     //老版本语法: Firefox (buggy) </span><br><span class="line">    display: -ms-flexbox;  //混合版本语法: IE <span class="number">10</span> </span><br><span class="line">    display: -webkit-flex; //新版本语法: Chrome <span class="number">21</span>+ </span><br><span class="line">    display: flex;         //新版本语法: Opera <span class="number">12.1</span>, Firefox <span class="number">22</span>+</span><br></pre></td></tr></table></figure>




<h2 id="浏览器hack"><a href="#浏览器hack" class="headerlink" title="浏览器hack"></a>浏览器hack</h2><p><img src="https://pic1.zhimg.com/v2-46cac38591afd23945a60713cf0bc49c_b.jpg" alt="image"></p>
<p>1、Firefox</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@-moz-document</span> url-prefix() &#123; <span class="selector-class">.selector</span> &#123; property: value; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>上面是仅仅被Firefox浏览器识别的写法，具体如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@-moz-document</span> url-prefix() &#123; <span class="selector-class">.demo</span> &#123; <span class="attribute">color</span>:lime; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>支持Firefox的还有几种写法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 支持所有firefox版本 */</span> <span class="selector-id">#selector</span><span class="selector-attr">[id=selector]</span> &#123; property: value; &#125; </span><br><span class="line">或者： <span class="keyword">@-moz-document</span> url-prefix() &#123; <span class="selector-class">.selector</span> &#123; property: value; &#125;  </span><br><span class="line"><span class="comment">/* 支持所有Gecko内核的浏览器 (包括Firefox) */</span> *&gt;<span class="selector-class">.selector</span> &#123; property: value; &#125;</span><br></pre></td></tr></table></figure>

<p>2、Webkit枘核浏览器(chrome and safari)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">0</span>) &#123; Selector &#123; property: value; &#125; &#125;</span><br><span class="line"><span class="comment">/*上面写法主要是针对Webkit内核的浏览器，如Google Chrome 和 Safari浏览器：*/</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">0</span>) &#123; <span class="selector-class">.demo</span> &#123; <span class="attribute">color</span>: <span class="number">#f36</span>; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>3、Opera浏览器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span><span class="selector-pseudo">:first</span>-child&gt;<span class="selector-tag">body</span> Selector &#123;property:value;&#125;</span><br><span class="line"><span class="comment">/*或者：*/</span> <span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">0</span>) &#123; Selector &#123;property: value;&#125; &#125; </span><br><span class="line"><span class="comment">/*或者：*/</span> <span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">10000</span>), <span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">0</span>) &#123; head~<span class="selector-tag">body</span> Selector &#123; property: value; &#125; &#125;</span><br><span class="line"><span class="comment">/*上面则是Opera浏览器的Hack写法：*/</span></span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">10000</span>), <span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">0</span>) &#123; head~<span class="selector-tag">body</span> <span class="selector-class">.demo</span> &#123; <span class="attribute">background</span>: green; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>4、IE9浏览器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> Selector &#123;property: value9;&#125;</span><br><span class="line"><span class="comment">/*上面是IE9的写法，具体应用如下：*/</span></span><br><span class="line"><span class="selector-pseudo">:root</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: <span class="number">#ff0</span>9;&#125;</span><br></pre></td></tr></table></figure>
<p>5、IE9以及IE9以下版本</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Selector &#123;property:value9;&#125;</span><br><span class="line"><span class="comment">/*这种写法只有IE9以及IE9以下版本能识别，这里需要注意此处“9”只能是“9”不能是别的，比如说“8”，不然会失去效果的，如：*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.demo</span> &#123;<span class="attribute">background</span>: lime9;&#125;</span><br></pre></td></tr></table></figure>
<p>6、IE7浏览器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*+<span class="selector-tag">html</span> Selector&#123;property:value;&#125; 或 *<span class="selector-pseudo">:first</span>-child+<span class="selector-tag">html</span> Selector &#123;property:value;&#125;</span><br><span class="line"><span class="comment">/*上面两种是IE7浏览器下才能识别，如：*/</span></span><br><span class="line">*+<span class="selector-tag">html</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">background</span>: green;&#125; 或者： *<span class="selector-pseudo">:first</span>-child+<span class="selector-tag">html</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">background</span>: green;&#125;</span><br></pre></td></tr></table></figure>
<p>7、IE7及IE7以下版本浏览器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Selector &#123;*property: value;&#125;</span><br><span class="line">&#x2F;*上面的写法在IE7以及其以下版本都可以识别，如：*&#x2F;</span><br></pre></td></tr></table></figure>
<p>.demo {*background: red;}<br>8、IE6浏览器</p>
<pre><code>加_下划线即可
</code></pre>
<h3 id="CSS选择器的Hack写法"><a href="#CSS选择器的Hack写法" class="headerlink" title="CSS选择器的Hack写法"></a>CSS选择器的Hack写法</h3><p>下面我们主要来看CSS选择器和CSS属性选择器在不同浏览器的支持情况。下面先来看CSS选择器支持情况。</p>
<p>1、IE6以及IE6以下版本浏览器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* <span class="selector-tag">html</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br><span class="line">* ```</span><br><span class="line"><span class="number">2</span>、仅仅IE7浏览器</span><br><span class="line">```css</span><br><span class="line">*<span class="selector-pseudo">:first</span>-child+<span class="selector-tag">html</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure>
<p>3、除IE6之外的所有浏览器（IE7-9, Firefox,Safari,Opera）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&gt;<span class="selector-tag">body</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure>
<p>4、IE8-9,Firefox,Safari,Opear</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&gt;<span class="comment">/**/</span><span class="selector-tag">body</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure>
<p>5、IE9+</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure>
<p>6、Firefox浏览器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@-moz-document</span> url-prefix() &#123; <span class="selector-class">.demo</span> &#123; <span class="attribute">color</span>: red; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>7、Webkit内核浏览器（Safari和Google Chrome）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">0</span>) &#123; <span class="selector-class">.demo</span> &#123; <span class="attribute">color</span>: red; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>8、Opera浏览器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">10000</span>), <span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">0</span>) &#123; head~<span class="selector-tag">body</span> <span class="selector-class">.demo</span> &#123; <span class="attribute">color</span>: red; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>9、iPhone / mobile webkit</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-device-width</span>: <span class="number">480px</span>) &#123; <span class="selector-class">.demo</span> &#123; <span class="attribute">color</span>: red &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>CSS属性Hack写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1、IE6浏览器*/</span></span><br><span class="line"><span class="selector-class">.demo</span> &#123;_color: red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2、IE6-7浏览器识别*/</span></span><br><span class="line"><span class="selector-class">.demo</span> &#123;*<span class="attribute">color</span>: red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3、所有浏览器除IE6浏览外*/</span></span><br><span class="line"><span class="selector-class">.demo</span> &#123;<span class="attribute">color</span><span class="comment">/**/</span>:red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*4、IE6-9浏览器*/</span></span><br><span class="line"><span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: red9;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*5、IE7-8浏览器*/</span></span><br><span class="line"><span class="selector-class">.demo</span> &#123;<span class="attribute">color</span><span class="comment">/***/</span>:red9;&#125;</span><br></pre></td></tr></table></figure>
<p>IE条件注释，全部采用选择器Hack的写法。这种写法分两步：</p>
<p>1、创建条件样式表，并在HTML中body里添加相应的class类名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!–[if IE6]–&gt;&lt;&lt;!–[if IE7]–&gt;&lt;!–[if IE8]–&gt;&lt;!–[if IE9]–&gt;&lt;!–[if !IE]–&gt;</span><br></pre></td></tr></table></figure>
<p>2、接着创建对应的样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: blue;&#125;<span class="comment">/*现代浏览器*/</span> </span><br><span class="line"><span class="selector-class">.non-ie</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: red;&#125;<span class="comment">/*除IE外浏览器*/</span> </span><br><span class="line"><span class="selector-class">.ie9</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: yellow;&#125;<span class="comment">/*IE9浏览器*/</span> </span><br><span class="line"><span class="selector-class">.ie8</span> <span class="selector-class">.demo</span>&#123;<span class="attribute">color</span>: green;&#125;<span class="comment">/*IE8浏览器*/</span> </span><br><span class="line"><span class="selector-class">.ie7</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: orange;&#125;<span class="comment">/*IE7浏览器*/</span></span><br><span class="line"><span class="selector-class">.ie6</span> <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>: lime;&#125;<span class="comment">/*IE6浏览器*/</span> </span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">0px</span>)&#123; <span class="selector-class">.demo</span> &#123;<span class="attribute">color</span>:black;&#125; <span class="comment">/* webkit and opera */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">0</span>)&#123; <span class="selector-class">.demo</span>&#123;<span class="attribute">color</span>:<span class="number">#369</span>;&#125;<span class="comment">/* webkit */</span> </span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">10000</span>), <span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>:<span class="number">0</span>) &#123; head~<span class="selector-tag">body</span> <span class="selector-class">.demo</span>&#123;<span class="attribute">color</span>:<span class="number">#cf6</span>;&#125;<span class="comment">/* opera */</span> </span><br><span class="line"><span class="keyword">@-moz-document</span> url-prefix()&#123; <span class="selector-class">.demo</span>&#123;<span class="attribute">color</span>:<span class="number">#963</span>;&#125;<span class="comment">/* firefox * / </span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试必看</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串和数组常用方法</title>
    <url>/2021/02/27/js%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串的创建："><a href="#字符串的创建：" class="headerlink" title="字符串的创建："></a>字符串的创建：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br></pre></td></tr></table></figure>
<p>将任意类型的值转换成字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Var a = <span class="number">10</span>;</span><br><span class="line">Var str = a.toString(); <span class="comment">//string</span></span><br><span class="line">Var str1 = “”+a; <span class="comment">//string</span></span><br><span class="line">Var str2 = <span class="built_in">String</span>(a);<span class="comment">//string</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>　除了 slice() 和 substr() 方法里的负值是代表从右截取，其他方法里的负值一律作为0处理</p>
</blockquote>
<ol>
<li><p>charCodeAt方法返回一个整数，代表指定位置字符的Unicode编码。<br>Str.charCodeAt(index);如果指定位置没有字符，返回NaN；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.charCodeAt(<span class="number">3</span>));<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></li>
<li><p>fromCharCode方法从一些Unicode字符串中返回一个字符串。 </p>
</li>
<li><p>charAt方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。</p>
</li>
<li><p>slice方法返回字符串的片段。</p>
</li>
</ol>
<pre><code>strObj.slice(start[,end]) 

start下标从0开始的strObj指定部分起始索引。如果start为负，将它作为length+start处理，此处length为字符串的长度。 

end小标从0开始的strObj指定部分结束索引。如果end为负，将它作为length+end处理，此处length为字符串的长度。
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str1 = str.slice(<span class="number">0</span>,-<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> str2 = str.slice(-<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1,str2);<span class="comment">//a c</span></span><br></pre></td></tr></table></figure>
<p>5、substring方法返回位于String对象中指定位置的子字符串</p>
<pre><code>strObj.substring(start,end) 

    start指明子字符串的起始位置，该索引从0开始起算。 
        
    end指明子字符串的结束位置，该索引从0开始起算。 
        
    substring方法使用start和end两者中的较小值作为子字符串的起始点。如果start或end为NaN或者为负数，那么将其替换为0。
</code></pre>
<p>6、substr方法返回一个从指定位置开始的指定长度的子字符串。 </p>
<pre><code>    strObj.substr(start[,length]) 
    start所需的子字符串的起始位置。字符串中的第一个字符的索引为0。 
    length在返回的子字符串中应包括的字符个数。 
    var str = &quot;ABCDEF&quot;; 
    str.substr(2,4); //CDEF ；
    
</code></pre>
<p>7、indexOf方法返回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1。 </p>
<p>lastindexOf()方法从尾部开始寻找对象中第一次出现子字符串的位置</p>
<pre><code>    strObj.indexOf(substr[,startIndex]) 
    substr要在String对象中查找的子字符串。 
    startIndex该整数值指出在String对象内开始查找的索引。如果省略，则从字符串的开始处查找。 
    var str = &quot;ABCDECDF&quot;; 
    str.indexOf(&quot;CD&quot;，1); // 由1位置从左向右查找 123... 结果：2 
    
</code></pre>
<p>8、search方法返回与正则表达式查找内容匹配的第一个字符串的位置。 </p>
<pre><code>    strObj.search(reExp) 
    reExp包含正则表达式模式和可用标志的正则表达式对象。 
    var str = &quot;ABCDECDF&quot;; 
    str.search(&quot;CD&quot;); // 或 str.search(/CD/i); 结果：2 
    
</code></pre>
<p>9、concat方法返回字符串值，该值包含了两个或多个提供的字符串的连接。 </p>
<pre><code>    str.concat([string1[,string2...]]) 
    string1，string2要和所有其他指定的字符串进行连接的String对象或文字。 
    var str = &quot;ABCDEF&quot;; 
    str.concat(&quot;ABCDEF&quot;,&quot;ABC&quot;); 
    结果：ABCDEFABCDEFABC
</code></pre>
<p>10、Split将一个字符串分割为子字符串，然后将结果作为字符串数组返回。 </p>
<pre><code>    strObj.split([separator[,limit]]) 
    separator字符串或 正则表达式 对象，它标识了分隔字符串时使用的是一个还是    多个字符。如果忽略该选项，返回包含整个字符串的单一元素数组。 
    limit该值用来限制返回数组中的元素个数。 
    var str = &quot;AA BB CC DD EE FF&quot;; 
    alert(str.split(&quot; &quot;，3)); 
    结果： AA,BB,CC 
</code></pre>
<p>11、 toLowerCase方法用于将一个字符串全部转为小写</p>
<p>toUpperCase则是全部转为大写。</p>
<p>它们都返回一个新字符串，不改变原字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot; hello word &quot;</span>.trim());</span><br><span class="line"><span class="comment">//hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>.toLowerCase());</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>.toUpperCase());</span><br><span class="line"><span class="comment">// &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure>
<p>12、trim(): 用于去除字符串两端的空白，返回一个新字符串 不改变原数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27; hello world &#x27;</span>.trim())； <span class="comment">//hello word</span></span><br></pre></td></tr></table></figure>
<p>13、replace 返回被替换的字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.replace(rgExp/substr,replaceText)  </span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote>
<p>数组的概念：有序的元素的集合    使用数字作为索引的一个对象  索引为从0开始的整数</p>
</blockquote>
<h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>1、构造数组  var arr = new Array（）；</p>
<p>向数组中添加元素：数组[索引] = 值；<br>读取数组  数组[索引]  当索引值比数组长度大时，会返回undefined；<br>数组长度：数组.length;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr1.length = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1,arr1.length); <span class="comment">//如果修改的length大于原长度，则多出部分会空出来；</span></span><br><span class="line">arr1.length = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1,arr1.length); <span class="comment">//如果修改的length小于原长度，则多出的部分会删除；</span></span><br></pre></td></tr></table></figure>
<p>2、字面量创建数组   var arr = []；</p>
<p>中括号里边可以直接添加元素（可以是任意类型的数据类型）；</p>
<h2 id="数组的操作方法"><a href="#数组的操作方法" class="headerlink" title="数组的操作方法"></a>数组的操作方法</h2><p>1、push（） 可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度</p>
<p>2、Pop（） 数组末尾移除最后一项，减少数组的LENGTH值，并返回被删除的元素</p>
<p>3、Unshift（） 在数组的头部添加一个或者多个元素，返回增加后数组的长度</p>
<p>4、Shift（）     从数组的头部删除一个元素并返回这个删除的元素，如果数组为空则返回undefined；</p>
<p>5、Slice（）返回从原数组中指定开始下标到结束下标之间的项组成的新数组。</p>
<pre><code>slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。
在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。
如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。
var a = arr(0,2);
第二个参数可以是负值：则从后往前截取 -1：最后一个
</code></pre>
<p>6、splice:</p>
<pre><code>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。

插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。

替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。
splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。
</code></pre>
<p>7、join()</p>
<pre><code>将数组的元素组成一个字符串
不会对原数据产生影响，会把转化后的字符串作为结果返回
在join（）中可以指定一个字符串作为参数，这个字符串将会作为数组中元素的连接符，如果不指定连接符，默认为逗号
</code></pre>
<p>8、reverse():<br>用来反转数组，前面的去后面，后面的去前面；</p>
<p>9、Sort（） 对数组成员进行排序，默认按照字典顺序排序，原数组会改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;<span class="comment">//升序</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面</p>
<p>10、concat() ：将参数添加到原数组中。</p>
<pre><code>这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。 
</code></pre>
<p>11、indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。 </p>
<p>12、lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。</p>
<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。</p>
<p>13、forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；对应的数组索引，数组本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>];<span class="comment">//1 0 true；2 1  true；6 2 true；4 3 true</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">x,index,a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x+<span class="string">&quot; &quot;</span>+index+<span class="string">&quot; &quot;</span>+(a===arr));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>14、map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">32</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>];</span><br><span class="line"><span class="keyword">var</span> arr = arr1.map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+<span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">//[35,8,14,15]</span></span><br></pre></td></tr></table></figure>
<p>15、filter(): 用于过滤数组成员，满足条件的成员组成一个 新数组返回 原数组不变<br>它的参数是一个函数，所有数组成员一次执行，返回结果为 true 的元素组成一个新数组返回<br>第一个参数：当前成员<br>第二个参数：当前成员的索引<br>第三个参数：整个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">21</span>,<span class="number">152</span>,<span class="number">66</span>,<span class="number">565</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = arr2.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x,index</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr3);<span class="comment">//[21,66];</span></span><br></pre></td></tr></table></figure>
<p>15、every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</p>
<p>16、some():判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//every</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">26</span>,<span class="number">641</span>,<span class="number">15312</span>,<span class="number">63</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> arr5 = arr4.every(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &gt; <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr5);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//some</span></span><br><span class="line"><span class="keyword">var</span> arr7 = arr4.some(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &gt; <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr7);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>17、reduce(): 将内部的返回值作为实参传递第一个形参，进行下一次运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//1+2+3+5=11</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数组</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>原型和原型链</title>
    <url>/2021/02/27/js%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<blockquote>
<p>js中有一个话，叫万物皆对象，因为js是基于原型的</p>
</blockquote>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>当我们创建一个对象时 let obj = { age: 25 }，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？</p>
<p>当我们在浏览器中打印 obj 时你会发现，在 obj 上居然还有一个 <strong>proto</strong> 属性，那么看来之前的疑问就和这个属性有关系了。</p>
<p>其实每个 JS 对象都有 <strong>proto</strong> 属性，这个属性指向了原型。这个属性在现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问到内部属性 [[prototype]] 来实现的一个东西。</p>
<p>讲到这里好像还是没有弄明白什么是原型，接下来让我们再看看 <strong>proto</strong> 里面有什么吧。</p>
<p>看到这里你应该明白了，原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 obj 来说，可以通过 <strong>proto</strong> 找到一个原型对象，在该对象中定义了很多函数让我们来使用。</p>
<p>在上面的图中我们还可以发现一个 constructor 属性，也就是构造函数</p>
<p>打开 constructor 属性我们又可以发现其中还有一个 prototype 属性，并且这个属性对应的值和先前我们在 <strong>proto</strong> 中看到的一模一样。所以我们又可以得出一个结论：原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型，但是并不是所有函数都具有这个属性，Function.prototype.bind() 就没有这个属性。</p>
<p>其实原型就是那么简单，接下来我们再来看一张图，相信这张图能让你彻底明白原型和原型链</p>
<p>看完这张图，我再来解释下什么是原型链吧。其实原型链就是多个对象通过 <strong>proto</strong> 的方式连接了起来。为什么 obj 可以访问到 valueOf 函数，就是因为 obj 通过原型链找到了 valueOf 函数。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类与类之间的关系  基类 父类 子类</p>
<pre><code>//call&amp;apply方法实现继承
        function Person(name,age)&#123;
            this.name = name;
            this.age = age;
            this.sayHello = function ()&#123;
                console.log(this.name);
            &#125;
        &#125;
        function Male(name,age)&#123;
            //继承父类Person  call&amp;apply 调用的是父类的构造函数
//                Person.call(this,name,age);
            Person.apply(this,[name,age]);
        &#125;
        var male = new Male(&quot;ly&quot;,20);
        male.sayHello();
        
        
        //原型继承
        
        //
        
        //每一个构造函数都有一个原型对象(也就是Person.prototype)，每一个原型对象都有一个指针constructor指向构造函数，每一个实例都有一个内部指针（__proto__），指向原型对象，原型对象上的属性和方法能被实例所访问
        //这里不能用call&amp;apply的原因是父类的构造函数里边什么也没有 现在要调用的是父类的原型对象
        /*function Person()&#123;
            
        &#125;
        //Person.prototype里的属性和方法可以被Person的实例访问到
        Person.prototype.name = &quot;jhon&quot;;
        Person.prototype.age = 20;
        Person.prototype.sayHello = function ()&#123;
            console.log(this.name);
        &#125;
        function Male()&#123;
            this.sayHi=function ()&#123;
                console.log(&quot;aa&quot;)
            &#125;
        &#125;
        //Male.prototype.__proto__ 指向Person.prototype
        Male.prototype = new Person();
        //Male.prototype = Person.prototype;
        var male = new Male();
        male.sayHello();
        console.log(male.__proto__);//正常情况下应该指向Male.prototype 但是现在指向Person.prototype
        //male.__proto__ -&gt; Male.prototype   Male.prototype.__proto__ -&gt; Person.prototype
        //当male调用sayhello方法时会找到Male.prototype，如果Male.prototype没有的话就会继续向它的父类找，直到找到Object.prototype停止，Object.prototype.__proto__为null
        
        //原型链  原型链上的属性和方法都能被实例所访问到 
        
        console.log(male.__proto__ == Male.prototype);//true
        console.log(Male.prototype.__proto__ == Person.prototype);//true
        male.sayHi();
        var obj = &#123;&#125;;
        //将其他类型转换成字符串时，默认会调用toString方法，这个方法是顶层原型对象上的方法，可以改写,改写之后，转换的结果以改写结果为准
        obj.toString = function()&#123;
            return 111111;
        &#125;
        document.write(obj);//111111*/
        
        //组合继承
        /*function Person(name,age)&#123;
            this.name = name;
            this.age = age;
        &#125;
        Person.prototype.sayHello = function ()&#123;
            console.log(this.name);
        &#125;
        function Male(name,age)&#123;
            Person.call(this,name,age);
        &#125;
        //Male.prototype = new Person();
        //弊端在于Person.call的时候运行了一次构造函数Person，当Male.prototype = new Person()的时候又运行了一次
        
//            Male.prototype = Person.prototype;
//            //这时候Person.call指向的是Person里的name和age，而Male.prototype = Person.prototype指的是sayhello  弊端是这时候相当于传址，父类person的实例也能够访问到子类Male里的原型对象的方法，而这是不合道理的
//            Male.prototype.sayHi = function()&#123;
//                console.log(&quot;aa&quot;);
//            &#125;
//            var person = new Person();
//            person.sayHi();
      
        //遍历person.prototype    call继承实例属性 这种方式继承原型方法
        for(var i in Person.prototype)&#123;
            Male.prototype[i] = Person.prototype[i];
        &#125;
        var male = new Male(&quot;ly&quot;,20);
        male.sayHello();*/
        
        //寄生式组合继承  Object.create()
        /*var obj1 = &#123;a:1&#125;;
        var obj2 = &#123;b:2&#125;;
        var a = Object.create(obj1);
        console.log(a.__proto__);//结果是a:1  这时候的obj1是作为创建出来的实例a的原型对象存在 a.__proto__指obj1
        function Person(name,age)&#123;
            this.name = name;
            this.age = age;
        &#125;
        Person.prototype.sayHello = function ()&#123;
            console.log(this.name);
        &#125;
        function Male(name,age)&#123;
            Person.call(this,name,age);
        &#125;
        Male.prototype = Object.create(Person.prototype);
        Male.prototype.constructor = Male;
        var male = new Male(&quot;ly&quot;,20);
        male.sayHello();
        console.log(male.__proto__.constructor);//本来应该指向Male 但是现在指向了Person 需要加上Male.prototype.constructor = Male 让它的原型对象指向自己*/
        
        
        //ES6继承
        class Person&#123;
            constructor(name,age)&#123;
                this.name = name;
                this.age = age;
            &#125;
            sayHello()&#123;
                console.log(this.name);
            &#125;
            //static 是一个静态方法 也就是说foo可以认为是这个构造函数自带的一个方法
            static foo()&#123;
                console.log(&quot;aa&quot;);
            &#125;
        &#125;
        console.log(Person.prototype)
        //用到exends关键字和super方法
        class Male extends Person&#123;
            constructor(name,age)&#123;
                //相当于拿到了Person的this.name和this.age 同时改变了this指向
                super(name,age)
            &#125;
            sayHi()&#123;
                super.sayHello();
            &#125;
        &#125;
        var male = new Male(&quot;ly&quot;,20);
        male.sayHello();
        male.sayHi();//结果一样
</code></pre>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝</title>
    <url>/2021/02/27/js%E5%9F%BA%E7%A1%80/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>首先可以通过对象的Object.assign来进行浅拷贝，很多人认为<br>这个函数是用来深拷贝的。其实并不是，Object.assign<br>只会拷贝所有的属性值到新的对象中，如果属性值是对象的话<br>，拷贝的是地址，所以并不是深拷贝。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">  age: 1</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; Object.assign(&#123;&#125;, a)</span><br><span class="line">a.age &#x3D; 2</span><br><span class="line">console.log(b.age) &#x2F;&#x2F; 1    </span><br></pre></td></tr></table></figure>
<p>另外我们还可以通过展开运算符 … 来实现浅拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">  age: 1</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; &#123; ...a &#125;</span><br><span class="line">a.age &#x3D; 2</span><br><span class="line">console.log(b.age) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">  age: 1,</span><br><span class="line">  jobs: &#123;</span><br><span class="line">    first: &#39;FE&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; &#123; ...a &#125;</span><br><span class="line">a.jobs.first &#x3D; &#39;native&#39;</span><br><span class="line">console.log(b.jobs.first) &#x2F;&#x2F; native</span><br></pre></td></tr></table></figure>
<p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。</p>
<hr>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">  age: 1,</span><br><span class="line">  jobs: &#123;</span><br><span class="line">    first: &#39;FE&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(a))</span><br><span class="line">a.jobs.first &#x3D; &#39;native&#39;</span><br><span class="line">console.log(b.jobs.first) &#x2F;&#x2F; FE</span><br></pre></td></tr></table></figure>
<p>但是该方法也是有局限性的：</p>
<ul>
<li>会忽略 undefined</li>
<li>会忽略 symbol</li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象<blockquote>
<blockquote>
<p><a href="https://lodash.com/docs/4.17.11#cloneDeep">lodash 的深拷贝函数</a></p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  function isObject(o) &#123;</span><br><span class="line">    return (typeof o &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof o &#x3D;&#x3D;&#x3D; &#39;function&#39;) &amp;&amp; o !&#x3D;&#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!isObject(obj)) &#123;</span><br><span class="line">    throw new Error(&#39;非对象&#39;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let isArray &#x3D; Array.isArray(obj)</span><br><span class="line">  let newObj &#x3D; isArray ? [...obj] : &#123; ...obj &#125;</span><br><span class="line">  Reflect.ownKeys(newObj).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">    newObj[key] &#x3D; isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注：<br>Reflect.ownKeys(target)<br>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable影响).</li>
</ul>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>浅拷贝</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础类型</title>
    <url>/2021/02/25/js%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><p>Es5规定的基础类型为6种：number,string,undefined,null,boolean,object<br>其中 number,string,undefined,boolean,null 被称为原始类型，object 被称为对象类型</p>
<h3 id="原始类型和对象类型的区别"><a href="#原始类型和对象类型的区别" class="headerlink" title="原始类型和对象类型的区别"></a>原始类型和对象类型的区别</h3><pre><code>原始类型存储的是值，而对象类型存储的是地址。在JS中创建一个对象类型A时，
会在浏览器内存中开辟一片空间来存放它的值，这个空间会拥有一个指针，
对象A的值是空间的指针也就是地址。当把A的值赋值给另一个对象B时，
并不是把A里的值赋值给B，而是把A的指针传给B，所以A和B的指针指向同一个地方，
当A或B中某一个的值发生改变时。另一个也会发生改变。
</code></pre>
<h4 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h4><h5 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h5><p>在使用var声明变量，但未对其加以初始化时，这个变量的类型就是undefined，且其默认初始化值为undefined。<br>对未声明与初始化的变量，直接使用，那么这个变量的类型也是undefined，但是没有默认初始化值。<br>//undefined<br>var message;<br>alert(‘已经声明但未初始化的变量message的类型是：’ +typeof message)<br>alert(‘未声明，也未初始化的变量age的类型是：’+ typeof age)<br>message</p>
<p>age</p>
<p>【总结】因为js的变量都是用关键字var来声明的，变量的具体类型取决于他被赋予的变量值，而对于以上两种情况，虽然本质上有区别，但是都没有被初始化，所以其类型都是undefined。但是后者没有初始化值。所以当<br>alert(age);//产生错误</p>
<h5 id="null"><a href="#null" class="headerlink" title="null"></a>null</h5><p>null类型的默认值是null，从逻辑角度讲，是表示一个空对象指针。<br>js高级程序上有讲到，undefined类型是派生自null的，不严格的说二者都是指没有明确赋值的类型，但是细分之后，undefined类型，被用来形容未经初始化的变量，null类型被用来形容空对象指针。<br>所以，如果定义的变量准备在将来用于保存对象（即复杂的数据类型object），那么就该将该变量初始化为null。<br>区分，当一个变量声明后，未初始化，则该值为undefined，如果这个值是为了保存对象，则修改其默认初始化的值，改为null。 所以当检测其类型时，会显示类型为object。<br>*所以有时候，当问到js基本数据类型时，会忽略null。<br>//null<br>var car=null;<br>alert(‘car的类型为：’typeof car)</p>
<p>car=null</p>
<h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><p>即布尔类型，该类型有两个值：true false<br>Bloolean()函数，可以将其他类型的值转换为布尔类型。<br>转换规则<br><img src="/2021/02/25/js%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/boolean-rule.webp" alt="布尔类型转换规则"></p>
<p>规则<br>这些转换规则对理解流程控制语句，如（if）语句自动执行相应的转换非常重要。</p>
<h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><p>该类型的表示方法有两种形式，第一种是整数，第二种为浮点数。<br>整数 可以通过十进制，八进制，十六进制的字面值来表示。<br>var intNum=55;//十进制<br>var octalNum=070;//八进制数，第一位必须是0，解析为56<br>var octalNum=079;//无效的8进制数，9超过了8进制数的范围，解析为79<br>var hexNum=0xA;//十六进制数，前两位必须是0x，后跟16进制数字（09及AF）<br>浮点数<br>1、该数值中必须包含一个小数点，且小数点后必须有一位数字，如果小数点后只有零，则该小数会被转化为整数。<br>2、浮点数所占据的内存空间是整数的两倍。<br>3、对极大极小的浮点数采用e表示法。<br>var floatNum=3.2e7；//3.2×10（7次幂）<br>var floatNum=3.2e-7；//3.2×10（-7次幂）<br>NaN<br>1、即非数值，是一个特殊的值，这个数值用于表示一个本来要返回数值的操作数，未返回数值的情况。比如任何数值除以0，本是不符合规范的，js里，这样的操作返回NaN（但是实际上，只有0除以0时返回NaN，其他则无穷值）。<br>2、NaN有两个不同寻常的特点：任何涉及NaN的操作都会返回NaN，NaN值与任何值都不相等，包括本身。<br>3、isNaN()函数，这个函数可以判断，传递的参数是否“不是数值”这里涉及数值转换的问题，例如“10”这个字符串就可以转换为10，但是“blue”这个字符串则无法转换为数字，所以isNaN(“blue”)==true<br>数值转换<br>1、有三个函数可以把非数值转换为数值：Number()，parseInt()，parseFloat()。第一个可以用于任何数据类型，后两个，则专门用于把字符串转化为数值。<br>2、这三个函数对于同样的输入有不同的效果。<br>3、数值转换（另写一篇文章）</p>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>字符串类型是最熟悉不过的啦，至于用单引号，还是双引号，在js中还是没有差别的。记得成对出现。<br>var firstName=’zakas’;<br>字符串中一些特殊的字面量，即转义序列。类似于c语言学过的那些、<br>toString()函数，每个值都有，但是null与undefined没有。一般情况下使用这个函数时，没有必要传递参数，但是调用数值的 toString()方法时，可以传递基数，默认传递的是10，代表十进制。<br>String()函数可以将任何类型的值转换为字符串，包括null转换为’null’、undefined转换为’undefined’。<br>复杂的数据类型</p>
<h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><p>该类型实例化的对象，是一组数据和功能（函数）的集合。<br>实例化对象的过程有两种，一种是通过new操作符，一种是通过对象字面量表示法。<br>object类型是最基本的类型，我们可以在其基础上继承出更多的类型，像我们知道的Array()、Date()、还有有意思的function()类型，都是从object继承的，而且这些类型都在程序员使用前被默认设置了属性和方法，供程序员调用。<br>而以上类型又有一个笼统的称呼为引用类型。为什么是引用类型呢？<br>var obj=new Object();<br>在学习C的时候，知道“ int a; int &amp;ra=a;”，所以ra是a的引用，ra的类型为引用类型，系统并不为引用类型分配内存空间。<br>但是，js所指的引用类型，在《js高级程序设计》这本书里，也确实是这样的概念，obj只是引用类型，是堆内存中一个对象的别称，本身并不占用内存。</p>
<p>如图1</p>
<p>但是这本书里，也说对引用类型的访问是按照引用访问，但是当<br>var obj2=obj;<br>这样将obj的值复给obj2时，会将堆内存中object的地址赋给obj2，这句话，又貌似是在说，在声明一个引用类型时，是会将实例化对象地址存到栈内存中，然后通过地址访问堆内存。</p>
<p>如图2</p>
<p>还有一个难点，也是我在学习引用类型的时候困惑的地方，C的时候，引用是可以做参数传递的，而且，引用不能被赋值，即不能改变引用的值。但是js中，函数的参数都是值传递的，而对于js内的引用类型，其值，也就默认为栈内存中的地址。<br>现在，对于创建对象的内存图，我查了广大网友的资料，大家默认图2,希望有对js引用类型理解更清晰的朋友，可以告诉我一下。谢谢啦！</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
</search>
